---
title: "Main Analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidyr)
library(readr)
library(sf)
library(ggplot2)
library(rgdal)
library(broom)
library(tidytext)
library(ggwordcloud)
library(plotly)
```


# Sensor Data

## Import
```{r}
# Solved the datetime problem, just change class using other functions, not readr

MobileSensorReadings <- read_csv("DC5-Data/Sensor Data and Maps/MobileSensorReadings.csv") %>% 
  mutate(time = as.POSIXct(Timestamp)) %>% select(-Timestamp)

StaticSensorLocations <- read_csv("DC5-Data/Sensor Data and Maps/StaticSensorLocations.csv")

StaticSensorReadings <- read_csv("DC5-Data/Sensor Data and Maps/StaticSensorReadings.csv") %>% 
  mutate(time = as.POSIXct(Timestamp)) %>% select(-Timestamp)

# Image no label with colored neighborhoods
img <- png::readPNG("DC5-Data/Sensor Data and Maps/StHimarkNeighborhoodMapNoLabels.png")
```

```{r}
StHimark <- st_read(
  "DC5-Data/Sensor Data and Maps/StHimarkNeighborhoodShapefiles/StHimark.shp")
```

## Shapefile 

```{r}
map <- ggplot() + 
  geom_sf(data = StHimark, size = 0.25, color = "white", fill = "#69b3a2") + 
  ggtitle("Boundary Plot") + 
  # coord_sf(xlim = c(0,100), ylim = c(0,100)) +
  theme_void() 

ggplotly(map)
```

ask about extensions and shapefile, whether we can just use the shapefile itself 


## Sensor 

### Mobile

Aggregate through time 

```{r}
MobileSensorReadings_by_min <- MobileSensorReadings %>%
  group_by(time) %>% mutate(min_Value = sum(Value)) %>% distinct(time, .keep_all=T)%>%
  select(time, min_Value)
max(MobileSensorReadings_by_min$min_Value) # 2020-04-09 02:43:25	
ggplot(MobileSensorReadings_by_min, aes(x=time, y=min_Value)) + geom_line()
```


```{r}
# map + geom_point(data = MobileSensorReadings, aes(x=Long, y=Lat))
set.seed(21)
small_MobileSensorReadings <- MobileSensorReadings %>%
  sample_frac(0.2)
ggplot() + geom_point(data = small_MobileSensorReadings, aes(x=Long, y=Lat)) +
  geom_point(data = StaticSensorLocations, aes(x = Long, y = Lat, color = "red")) 
```

By location

```{r}
set.seed(21)
MobileSensorReadings_byloc <- small_MobileSensorReadings %>%
  sample_frac(0.001) %>% # test smaller 
  mutate(hour=lubridate::floor_date(time, "1 hour")) %>%
  group_by(Long, Lat, hour) %>% mutate(min_Value = sum(Value))

fig <- MobileSensorReadings_byloc %>%
  plot_ly(
    x = ~Long, 
    y = ~Lat, 
    size = ~min_Value, 
    color = ~min_Value, 
    frame = ~as.character(hour), 
    type = 'scatter',
    mode = 'markers'
  )%>%
  animation_opts(0) %>%
  layout(
    image = list(  
      source =  raster2uri(as.raster(img)),
      xref = "x", yref = "y",
      x = -119.9999,  y = 0.017057,
      xanchor = "left", yanchor = "bottom",
      sizex = 0.288152,
      # max(MobileSensorReadings$Long)-min(MobileSensorReadings$Long), 
      sizey =0.221315, 
      # max(MobileSensorReadings$Lat)-min(MobileSensorReadings$Lat),
      sizing = "stretch"
      # opacity = 0.8,
      # layer = "below"
    )
  )
fig

plot_ly(x = c(-119.9999, -119.7117), y = c(0.017057,0.238372)) %>%
  layout(
    image = list(
      source =  raster2uri(as.raster(img)),
      x = -119.9999,  y = 0.017057,
      sizex = 0.288152, sizey =0.221315,
      xref = "x", yref = "y",
      xanchor = "left", yanchor = "bottom",
      sizing = "stretch"
    )
  )

plot_ly() %>%
  layout(
    images = list(
      source = raster2uri(as.raster(img)),
      x = -2, y = 2, 
      sizex = 2, sizey = 1,
      xref = "x", yref = "y",
      xanchor = "left", yanchor = "bottom",
      sizing = "stretch"
    )
  )
```


### Static

map 

```{r}
ggplot(data = StaticSensorLocations, aes(x=Long, y=Lat)) + 
  scale_y_continuous(limits = c(min(MobileSensorReadings$Lat),
                                max(MobileSensorReadings$Lat)),
                     expand = expansion(c(0.075,0))) +
  scale_x_continuous(limits = c(min(MobileSensorReadings$Long),
                                max(MobileSensorReadings$Long)),
                     expand = expansion(mult = c(0, 0))) + 
  ggpubr::background_image(img) +
  # geom_point(data = small_MobileSensorReadings, aes(x=Long, y=Lat), alpha = 0.2) +
  geom_point(data = StaticSensorLocations, aes(x = Long, y = Lat), 
                                               shape=23, fill="red", color="black",
                                               size = 4) +
  geom_text(aes(label=StaticSensorLocations$`Sensor-id`),hjust=-0.75, vjust=1)

```
 

```{r}
ggplot(data=StaticSensorReadings, aes(y=Value, x=time)) +
  geom_line() + 
  facet_wrap(~`Sensor-id`) + theme_bw()
```


# Text Analysis

```{r}
#Reading in the data
YInt_data <- read_csv("DC5-Data/Y*Int Social Media Data/YInt.csv")
```

```{r}
#Tidying the data

data(stop_words)
#Goal: I would like to be able to use token = "tweets" in order to preserve # and @ (which are important in understanding tweeting patterns). I don't understand the error message that comes up when I do that, though
YInt_word <- YInt_data %>%
  unnest_tokens(word, message) %>% 
  anti_join(stop_words)

YInt_word %>% 
  count(word, sort = TRUE)
```

```{r}
#There was something about a missing dog?
YInt_word %>% filter(str_detect(word, "missing"))
```

```{r}
#Generating a word cloud from the most frequent words

wordclouddata<- YInt_word %>% 
  #group_by(location) %>% 
  count(word, sort = TRUE) %>% 
  head(100)
#glimpse(wordclouddata)

set.seed(53)
ggplot(wordclouddata, aes(label = word, size = n)) +
  geom_text_wordcloud() #+
  #scale_size_area(max_size = 10) +
  #theme_minimal()
```


Goals from group meeting:
- word cloud for each location (preferably overlaid on map)
- missing dog (dachschund)
- anything interesting in messages


# Trying to overlay word clouds on map
```{r}
library(shiny)
```

```{r}
map2 <- ggplot() + 
  geom_sf(data = StHimark, size = 0.25, aes(fill = Nbrhood, color = Nbrhood)) + 
  ggtitle("Boundary Plot") + 
  coord_sf() +
  theme_void() +
  theme(legend.position = "none")
```


```{r}
wordclouddata<- YInt_word %>% 
  filter(location == "Old Town") %>% 
  count(word, sort = TRUE) %>% 
  head(10)

set.seed(53)
wordcloud <- ggplot(wordclouddata, aes(label = word, size = n)) +
  geom_text_wordcloud() #+
  #scale_size_area(max_size = 10) +
  #theme_minimal()

#subplot(map2, wordcloud)
#THIS WON'T WORK BECAUSE WORDCLOUDS HAVEN'T BEEN COMBINED WITH PLOTLY YET i'm so sad :'(
```
```{r}
x <- 1:3 
y <- 1:3
logos <- c("r-logo", "penguin", "rstudio")
# base64 encoded string of each image
uris <- purrr::map_chr(
  logos, ~ base64enc::dataURI(file = sprintf("images/%s.png", .x))
)
# hoverinfo = "none" will hide the plotly.js tooltip, but the 
# plotly_hover event will still fire
plot_ly(hoverinfo = "none") %>%
  add_text(x = x, y = y, customdata = uris, text = logos) %>%
  htmlwidgets::onRender(readLines("js/tooltip-image.js"))
```
Okay so THAT WORKED AND IT SHOWS IMAGES!!!
VERY IMPORTANT: source!!! I whole-scale copied and pasted that part, including the .js file which made the tooltip even possible, and I don't even know javascript so I should NOT take credit for that!! I got it from here: https://plotly-r.com/supplying-custom-data.html#fig:tooltip-image


